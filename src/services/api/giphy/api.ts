/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Giphy
 * Giphy API
 *
 * OpenAPI spec version: 1.0
 * Contact: support@giphy.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://api.giphy.com/v1".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface Gif
 */
export interface Gif {
    /**
     * An array of tags for this GIF (Note: Not available when using the Public Beta Key) 
     * @type {Array<string>}
     * @memberof Gif
     */
    tags?: Array<string>;
    /**
     * The unique bit.ly URL for this GIF
     * @type {string}
     * @memberof Gif
     */
    bitlyUrl?: string;
    /**
     * Currently unused
     * @type {string}
     * @memberof Gif
     */
    contentUrl?: string;
    /**
     * The date this GIF was added to the GIPHY database.
     * @type {Date}
     * @memberof Gif
     */
    createDatetime?: Date;
    /**
     * A URL used for embedding this GIF
     * @type {string}
     * @memberof Gif
     */
    embdedUrl?: string;
    /**
     * An array of featured tags for this GIF (Note: Not available when using the Public Beta Key) 
     * @type {Array<string>}
     * @memberof Gif
     */
    featuredTags?: Array<string>;
    /**
     * This GIF's unique ID
     * @type {string}
     * @memberof Gif
     */
    id?: string;
    /**
     * 
     * @type {GifImages}
     * @memberof Gif
     */
    images?: GifImages;
    /**
     * The creation or upload date from this GIF's source.
     * @type {Date}
     * @memberof Gif
     */
    importDatetime?: Date;
    /**
     * The MPAA-style rating for this content. Examples include Y, G, PG, PG-13 and R
     * @type {string}
     * @memberof Gif
     */
    rating?: string;
    /**
     * The unique slug used in this GIF's URL
     * @type {string}
     * @memberof Gif
     */
    slug?: string;
    /**
     * The page on which this GIF was found
     * @type {string}
     * @memberof Gif
     */
    source?: string;
    /**
     * The URL of the webpage on which this GIF was found.
     * @type {string}
     * @memberof Gif
     */
    sourcePostUrl?: string;
    /**
     * The top level domain of the source URL.
     * @type {string}
     * @memberof Gif
     */
    sourceTld?: string;
    /**
     * The date on which this gif was marked trending, if applicable.
     * @type {Date}
     * @memberof Gif
     */
    trendingDatetime?: Date;
    /**
     * Type of the gif. By default, this is almost always gif
     * @type {string}
     * @memberof Gif
     */
    type?: GifTypeEnum;
    /**
     * The date on which this GIF was last updated.
     * @type {Date}
     * @memberof Gif
     */
    updateDatetime?: Date;
    /**
     * The unique URL for this GIF
     * @type {string}
     * @memberof Gif
     */
    url?: string;
    /**
     * 
     * @type {User}
     * @memberof Gif
     */
    user?: User;
    /**
     * The username this GIF is attached to, if applicable
     * @type {string}
     * @memberof Gif
     */
    username?: string;
}

/**
 * Enum workaround as namespaces are not supported
 */
/**
 * @export
 * @enum {string}
 */
export enum GifTypeEnum {
    Gif = <any>'gif'
}

/**
 * An object containing data for various available formats and sizes of this GIF.
 * @export
 * @interface GifImages
 */
export interface GifImages {
    /**
     * 
     * @type {any}
     * @memberof GifImages
     */
    downsized?: Image;
    /**
     * 
     * @type {any}
     * @memberof GifImages
     */
    downsizedLarge?: Image;
    /**
     * 
     * @type {any}
     * @memberof GifImages
     */
    downsizedMedium?: Image;
    /**
     * 
     * @type {any}
     * @memberof GifImages
     */
    downsizedSmall?: Image;
    /**
     * 
     * @type {any}
     * @memberof GifImages
     */
    downsizedStill?: Image;
    /**
     * 
     * @type {any}
     * @memberof GifImages
     */
    fixedHeight?: Image;
    /**
     * 
     * @type {any}
     * @memberof GifImages
     */
    fixedHeightDownsampled?: Image;
    /**
     * 
     * @type {any}
     * @memberof GifImages
     */
    fixedHeightSmall?: Image;
    /**
     * 
     * @type {any}
     * @memberof GifImages
     */
    fixedHeightSmallStill?: Image;
    /**
     * 
     * @type {any}
     * @memberof GifImages
     */
    fixedHeightStill?: Image;
    /**
     * 
     * @type {any}
     * @memberof GifImages
     */
    fixedWidth?: Image;
    /**
     * 
     * @type {any}
     * @memberof GifImages
     */
    fixedWidthDownsampled?: Image;
    /**
     * 
     * @type {any}
     * @memberof GifImages
     */
    fixedWidthSmall?: Image;
    /**
     * 
     * @type {any}
     * @memberof GifImages
     */
    fixedWidthSmallStill?: Image;
    /**
     * 
     * @type {any}
     * @memberof GifImages
     */
    fixedWidthStill?: Image;
    /**
     * 
     * @type {any}
     * @memberof GifImages
     */
    looping?: Image;
    /**
     * 
     * @type {any}
     * @memberof GifImages
     */
    original?: Image;
    /**
     * 
     * @type {any}
     * @memberof GifImages
     */
    originalStill?: Image;
    /**
     * 
     * @type {any}
     * @memberof GifImages
     */
    preview?: Image;
    /**
     * 
     * @type {any}
     * @memberof GifImages
     */
    previewGif?: Image;
}
/**
 * 
 * @export
 * @interface Image
 */
export interface Image {
    /**
     * The number of frames in this GIF.
     * @type {string}
     * @memberof Image
     */
    frames?: string;
    /**
     * The height of this GIF in pixels.
     * @type {string}
     * @memberof Image
     */
    height?: string;
    /**
     * The URL for this GIF in .MP4 format.
     * @type {string}
     * @memberof Image
     */
    mp4?: string;
    /**
     * The size in bytes of the .MP4 file corresponding to this GIF.
     * @type {string}
     * @memberof Image
     */
    mp4Size?: string;
    /**
     * The size of this GIF in bytes.
     * @type {string}
     * @memberof Image
     */
    size?: string;
    /**
     * The publicly-accessible direct URL for this GIF.
     * @type {string}
     * @memberof Image
     */
    url?: string;
    /**
     * The URL for this GIF in .webp format.
     * @type {string}
     * @memberof Image
     */
    webp?: string;
    /**
     * The size in bytes of the .webp file corresponding to this GIF.
     * @type {string}
     * @memberof Image
     */
    webpSize?: string;
    /**
     * The width of this GIF in pixels.
     * @type {string}
     * @memberof Image
     */
    width?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {Array<Gif>}
     * @memberof InlineResponse200
     */
    data?: Array<Gif>;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse200
     */
    meta?: Meta;
    /**
     * 
     * @type {Pagination}
     * @memberof InlineResponse200
     */
    pagination?: Pagination;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {Gif}
     * @memberof InlineResponse2001
     */
    data?: Gif;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse2001
     */
    meta?: Meta;
}
/**
 * The Meta Object contains basic information regarding the request, whether it was successful, and the response given by the API.  Check `responses` to see a description of types of response codes the API might give you under different cirumstances. 
 * @export
 * @interface Meta
 */
export interface Meta {
    /**
     * HTTP Response Message
     * @type {string}
     * @memberof Meta
     */
    msg?: string;
    /**
     * A unique ID paired with this response from the API.
     * @type {string}
     * @memberof Meta
     */
    responseId?: string;
    /**
     * HTTP Response Code
     * @type {number}
     * @memberof Meta
     */
    status?: number;
}
/**
 * The Pagination Object contains information relating to the number of total results available as well as the number of results fetched and their relative positions. 
 * @export
 * @interface Pagination
 */
export interface Pagination {
    /**
     * Total number of items returned.
     * @type {number}
     * @memberof Pagination
     */
    count?: number;
    /**
     * Position in pagination.
     * @type {number}
     * @memberof Pagination
     */
    offset?: number;
    /**
     * Total number of items available.
     * @type {number}
     * @memberof Pagination
     */
    totalCount?: number;
}
/**
 * The User Object contains information about the user associated with a GIF and URLs to assets such as that user's avatar image, profile, and more.
 * @export
 * @interface User
 */
export interface User {
    /**
     * The URL for this user's avatar image.
     * @type {string}
     * @memberof User
     */
    avatarUrl?: string;
    /**
     * The URL for the banner image that appears atop this user's profile page.
     * @type {string}
     * @memberof User
     */
    bannerUrl?: string;
    /**
     * The display name associated with this user (contains formatting the base username might not).
     * @type {string}
     * @memberof User
     */
    displayName?: string;
    /**
     * The URL for this user's profile.
     * @type {string}
     * @memberof User
     */
    profileUrl?: string;
    /**
     * The Twitter username associated with this user, if applicable.
     * @type {string}
     * @memberof User
     */
    twitter?: string;
    /**
     * The username associated with this user.
     * @type {string}
     * @memberof User
     */
    username?: string;
}

/**
 * GifsApi - fetch parameter creator
 * @export
 */
export const GifsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a GIF given that GIF's unique ID 
         * @summary Get GIF by Id
         * @param {number} gifId Filters results by specified GIF ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGifById(gifId: number, options: any = {}): FetchArgs {
            // verify required parameter 'gifId' is not null or undefined
            if (gifId === null || gifId === undefined) {
                throw new RequiredError('gifId', 'Required parameter gifId was null or undefined when calling getGifById.');
            }
            const localVarPath = `/gifs/{gifId}`
                .replace(`{${"gifId"}}`, encodeURIComponent(String(gifId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("api_key")
                    : configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A multiget version of the get GIF by ID endpoint. 
         * @summary Get GIFs by ID
         * @param {string} [ids] Filters results by specified GIF IDs, separated by commas.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGifsById(ids?: string, options: any = {}): FetchArgs {
            const localVarPath = `/gifs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("api_key")
                    : configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a random GIF, limited by tag. Excluding the tag parameter will return a random GIF from the GIPHY catalog. 
         * @summary Random GIF
         * @param {string} [tag] Filters results by specified tag.
         * @param {string} [rating] Filters results by specified rating.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        randomGif(tag?: string, rating?: string, options: any = {}): FetchArgs {
            const localVarPath = `/gifs/random`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("api_key")
                    : configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (rating !== undefined) {
                localVarQueryParameter['rating'] = rating;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search all GIPHY GIFs for a word or phrase. Punctuation will be stripped and ignored.  Use a plus or url encode for phrases. Example paul+rudd, ryan+gosling or american+psycho. 
         * @summary Search GIFs
         * @param {string} q Search query term or prhase.
         * @param {number} [limit] The maximum number of records to return.
         * @param {number} [offset] An optional results offset.
         * @param {string} [rating] Filters results by specified rating.
         * @param {string} [lang] Specify default language for regional content; use a 2-letter ISO 639-1 language code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchGifs(q: string, limit?: number, offset?: number, rating?: string, lang?: string, options: any = {}): FetchArgs {
            // verify required parameter 'q' is not null or undefined
            if (q === null || q === undefined) {
                throw new RequiredError('q', 'Required parameter q was null or undefined when calling searchGifs.');
            }
            const localVarPath = `/gifs/search`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("api_key")
                    : configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (rating !== undefined) {
                localVarQueryParameter['rating'] = rating;
            }

            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The translate API draws on search, but uses the GIPHY `special sauce` to handle translating from one vocabulary to another. In this case, words and phrases to GIF 
         * @summary Translate phrase to GIF
         * @param {string} s Search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translateGif(s: string, options: any = {}): FetchArgs {
            // verify required parameter 's' is not null or undefined
            if (s === null || s === undefined) {
                throw new RequiredError('s', 'Required parameter s was null or undefined when calling translateGif.');
            }
            const localVarPath = `/gifs/translate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("api_key")
                    : configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            if (s !== undefined) {
                localVarQueryParameter['s'] = s;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch GIFs currently trending online. Hand curated by the GIPHY editorial team.  The data returned mirrors the GIFs showcased on the GIPHY homepage. Returns 25 results by default. 
         * @summary Trending GIFs
         * @param {number} [limit] The maximum number of records to return.
         * @param {number} [offset] An optional results offset.
         * @param {string} [rating] Filters results by specified rating.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trendingGifs(limit?: number, offset?: number, rating?: string, options: any = {}): FetchArgs {
            const localVarPath = `/gifs/trending`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("api_key")
                    : configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (rating !== undefined) {
                localVarQueryParameter['rating'] = rating;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GifsApi - functional programming interface
 * @export
 */
export const GifsApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Returns a GIF given that GIF's unique ID 
         * @summary Get GIF by Id
         * @param {number} gifId Filters results by specified GIF ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGifById(gifId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
            const localVarFetchArgs = GifsApiFetchParamCreator(configuration).getGifById(gifId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * A multiget version of the get GIF by ID endpoint. 
         * @summary Get GIFs by ID
         * @param {string} [ids] Filters results by specified GIF IDs, separated by commas.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGifsById(ids?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
            const localVarFetchArgs = GifsApiFetchParamCreator(configuration).getGifsById(ids, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a random GIF, limited by tag. Excluding the tag parameter will return a random GIF from the GIPHY catalog. 
         * @summary Random GIF
         * @param {string} [tag] Filters results by specified tag.
         * @param {string} [rating] Filters results by specified rating.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        randomGif(tag?: string, rating?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
            const localVarFetchArgs = GifsApiFetchParamCreator(configuration).randomGif(tag, rating, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Search all GIPHY GIFs for a word or phrase. Punctuation will be stripped and ignored.  Use a plus or url encode for phrases. Example paul+rudd, ryan+gosling or american+psycho. 
         * @summary Search GIFs
         * @param {string} q Search query term or prhase.
         * @param {number} [limit] The maximum number of records to return.
         * @param {number} [offset] An optional results offset.
         * @param {string} [rating] Filters results by specified rating.
         * @param {string} [lang] Specify default language for regional content; use a 2-letter ISO 639-1 language code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchGifs(q: string, limit?: number, offset?: number, rating?: string, lang?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
            const localVarFetchArgs = GifsApiFetchParamCreator(configuration).searchGifs(q, limit, offset, rating, lang, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The translate API draws on search, but uses the GIPHY `special sauce` to handle translating from one vocabulary to another. In this case, words and phrases to GIF 
         * @summary Translate phrase to GIF
         * @param {string} s Search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translateGif(s: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
            const localVarFetchArgs = GifsApiFetchParamCreator(configuration).translateGif(s, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetch GIFs currently trending online. Hand curated by the GIPHY editorial team.  The data returned mirrors the GIFs showcased on the GIPHY homepage. Returns 25 results by default. 
         * @summary Trending GIFs
         * @param {number} [limit] The maximum number of records to return.
         * @param {number} [offset] An optional results offset.
         * @param {string} [rating] Filters results by specified rating.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trendingGifs(limit?: number, offset?: number, rating?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
            const localVarFetchArgs = GifsApiFetchParamCreator(configuration).trendingGifs(limit, offset, rating, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * GifsApi - factory interface
 * @export
 */
export const GifsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns a GIF given that GIF's unique ID 
         * @summary Get GIF by Id
         * @param {number} gifId Filters results by specified GIF ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGifById(gifId: number, options?: any) {
            return GifsApiFp(configuration).getGifById(gifId, options)(fetch, basePath);
        },
        /**
         * A multiget version of the get GIF by ID endpoint. 
         * @summary Get GIFs by ID
         * @param {string} [ids] Filters results by specified GIF IDs, separated by commas.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGifsById(ids?: string, options?: any) {
            return GifsApiFp(configuration).getGifsById(ids, options)(fetch, basePath);
        },
        /**
         * Returns a random GIF, limited by tag. Excluding the tag parameter will return a random GIF from the GIPHY catalog. 
         * @summary Random GIF
         * @param {string} [tag] Filters results by specified tag.
         * @param {string} [rating] Filters results by specified rating.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        randomGif(tag?: string, rating?: string, options?: any) {
            return GifsApiFp(configuration).randomGif(tag, rating, options)(fetch, basePath);
        },
        /**
         * Search all GIPHY GIFs for a word or phrase. Punctuation will be stripped and ignored.  Use a plus or url encode for phrases. Example paul+rudd, ryan+gosling or american+psycho. 
         * @summary Search GIFs
         * @param {string} q Search query term or prhase.
         * @param {number} [limit] The maximum number of records to return.
         * @param {number} [offset] An optional results offset.
         * @param {string} [rating] Filters results by specified rating.
         * @param {string} [lang] Specify default language for regional content; use a 2-letter ISO 639-1 language code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchGifs(q: string, limit?: number, offset?: number, rating?: string, lang?: string, options?: any) {
            return GifsApiFp(configuration).searchGifs(q, limit, offset, rating, lang, options)(fetch, basePath);
        },
        /**
         * The translate API draws on search, but uses the GIPHY `special sauce` to handle translating from one vocabulary to another. In this case, words and phrases to GIF 
         * @summary Translate phrase to GIF
         * @param {string} s Search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translateGif(s: string, options?: any) {
            return GifsApiFp(configuration).translateGif(s, options)(fetch, basePath);
        },
        /**
         * Fetch GIFs currently trending online. Hand curated by the GIPHY editorial team.  The data returned mirrors the GIFs showcased on the GIPHY homepage. Returns 25 results by default. 
         * @summary Trending GIFs
         * @param {number} [limit] The maximum number of records to return.
         * @param {number} [offset] An optional results offset.
         * @param {string} [rating] Filters results by specified rating.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trendingGifs(limit?: number, offset?: number, rating?: string, options?: any) {
            return GifsApiFp(configuration).trendingGifs(limit, offset, rating, options)(fetch, basePath);
        },
    };
};

/**
 * GifsApi - object-oriented interface
 * @export
 * @class GifsApi
 * @extends {BaseAPI}
 */
export class GifsApi extends BaseAPI {
    /**
     * Returns a GIF given that GIF's unique ID 
     * @summary Get GIF by Id
     * @param {number} gifId Filters results by specified GIF ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GifsApi
     */
    public getGifById(gifId: number, options?: any) {
        return GifsApiFp(this.configuration).getGifById(gifId, options)(this.fetch, this.basePath);
    }

    /**
     * A multiget version of the get GIF by ID endpoint. 
     * @summary Get GIFs by ID
     * @param {string} [ids] Filters results by specified GIF IDs, separated by commas.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GifsApi
     */
    public getGifsById(ids?: string, options?: any) {
        return GifsApiFp(this.configuration).getGifsById(ids, options)(this.fetch, this.basePath);
    }

    /**
     * Returns a random GIF, limited by tag. Excluding the tag parameter will return a random GIF from the GIPHY catalog. 
     * @summary Random GIF
     * @param {string} [tag] Filters results by specified tag.
     * @param {string} [rating] Filters results by specified rating.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GifsApi
     */
    public randomGif(tag?: string, rating?: string, options?: any) {
        return GifsApiFp(this.configuration).randomGif(tag, rating, options)(this.fetch, this.basePath);
    }

    /**
     * Search all GIPHY GIFs for a word or phrase. Punctuation will be stripped and ignored.  Use a plus or url encode for phrases. Example paul+rudd, ryan+gosling or american+psycho. 
     * @summary Search GIFs
     * @param {string} q Search query term or prhase.
     * @param {number} [limit] The maximum number of records to return.
     * @param {number} [offset] An optional results offset.
     * @param {string} [rating] Filters results by specified rating.
     * @param {string} [lang] Specify default language for regional content; use a 2-letter ISO 639-1 language code.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GifsApi
     */
    public searchGifs(q: string, limit?: number, offset?: number, rating?: string, lang?: string, options?: any) {
        return GifsApiFp(this.configuration).searchGifs(q, limit, offset, rating, lang, options)(this.fetch, this.basePath);
    }

    /**
     * The translate API draws on search, but uses the GIPHY `special sauce` to handle translating from one vocabulary to another. In this case, words and phrases to GIF 
     * @summary Translate phrase to GIF
     * @param {string} s Search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GifsApi
     */
    public translateGif(s: string, options?: any) {
        return GifsApiFp(this.configuration).translateGif(s, options)(this.fetch, this.basePath);
    }

    /**
     * Fetch GIFs currently trending online. Hand curated by the GIPHY editorial team.  The data returned mirrors the GIFs showcased on the GIPHY homepage. Returns 25 results by default. 
     * @summary Trending GIFs
     * @param {number} [limit] The maximum number of records to return.
     * @param {number} [offset] An optional results offset.
     * @param {string} [rating] Filters results by specified rating.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GifsApi
     */
    public trendingGifs(limit?: number, offset?: number, rating?: string, options?: any) {
        return GifsApiFp(this.configuration).trendingGifs(limit, offset, rating, options)(this.fetch, this.basePath);
    }

}

/**
 * StickersApi - fetch parameter creator
 * @export
 */
export const StickersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a random GIF, limited by tag. Excluding the tag parameter will return a random GIF from the GIPHY catalog. 
         * @summary Random Sticker
         * @param {string} [tag] Filters results by specified tag.
         * @param {string} [rating] Filters results by specified rating.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        randomSticker(tag?: string, rating?: string, options: any = {}): FetchArgs {
            const localVarPath = `/stickers/random`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("api_key")
                    : configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (rating !== undefined) {
                localVarQueryParameter['rating'] = rating;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replicates the functionality and requirements of the classic GIPHY search, but returns animated stickers rather than GIFs. 
         * @summary Search Stickers
         * @param {string} q Search query term or prhase.
         * @param {number} [limit] The maximum number of records to return.
         * @param {number} [offset] An optional results offset.
         * @param {string} [rating] Filters results by specified rating.
         * @param {string} [lang] Specify default language for regional content; use a 2-letter ISO 639-1 language code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchStickers(q: string, limit?: number, offset?: number, rating?: string, lang?: string, options: any = {}): FetchArgs {
            // verify required parameter 'q' is not null or undefined
            if (q === null || q === undefined) {
                throw new RequiredError('q', 'Required parameter q was null or undefined when calling searchStickers.');
            }
            const localVarPath = `/stickers/search`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("api_key")
                    : configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (rating !== undefined) {
                localVarQueryParameter['rating'] = rating;
            }

            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The translate API draws on search, but uses the GIPHY `special sauce` to handle translating from one vocabulary to another. In this case, words and phrases to GIFs. 
         * @summary Translate phrase to Sticker
         * @param {string} s Search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translateSticker(s: string, options: any = {}): FetchArgs {
            // verify required parameter 's' is not null or undefined
            if (s === null || s === undefined) {
                throw new RequiredError('s', 'Required parameter s was null or undefined when calling translateSticker.');
            }
            const localVarPath = `/stickers/translate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("api_key")
                    : configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            if (s !== undefined) {
                localVarQueryParameter['s'] = s;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch Stickers currently trending online. Hand curated by the GIPHY editorial team. Returns 25 results by default. 
         * @summary Trending Stickers
         * @param {number} [limit] The maximum number of records to return.
         * @param {number} [offset] An optional results offset.
         * @param {string} [rating] Filters results by specified rating.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trendingStickers(limit?: number, offset?: number, rating?: string, options: any = {}): FetchArgs {
            const localVarPath = `/stickers/trending`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("api_key")
                    : configuration.apiKey;
                localVarQueryParameter["api_key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (rating !== undefined) {
                localVarQueryParameter['rating'] = rating;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StickersApi - functional programming interface
 * @export
 */
export const StickersApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Returns a random GIF, limited by tag. Excluding the tag parameter will return a random GIF from the GIPHY catalog. 
         * @summary Random Sticker
         * @param {string} [tag] Filters results by specified tag.
         * @param {string} [rating] Filters results by specified rating.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        randomSticker(tag?: string, rating?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
            const localVarFetchArgs = StickersApiFetchParamCreator(configuration).randomSticker(tag, rating, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Replicates the functionality and requirements of the classic GIPHY search, but returns animated stickers rather than GIFs. 
         * @summary Search Stickers
         * @param {string} q Search query term or prhase.
         * @param {number} [limit] The maximum number of records to return.
         * @param {number} [offset] An optional results offset.
         * @param {string} [rating] Filters results by specified rating.
         * @param {string} [lang] Specify default language for regional content; use a 2-letter ISO 639-1 language code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchStickers(q: string, limit?: number, offset?: number, rating?: string, lang?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
            const localVarFetchArgs = StickersApiFetchParamCreator(configuration).searchStickers(q, limit, offset, rating, lang, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The translate API draws on search, but uses the GIPHY `special sauce` to handle translating from one vocabulary to another. In this case, words and phrases to GIFs. 
         * @summary Translate phrase to Sticker
         * @param {string} s Search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translateSticker(s: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
            const localVarFetchArgs = StickersApiFetchParamCreator(configuration).translateSticker(s, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetch Stickers currently trending online. Hand curated by the GIPHY editorial team. Returns 25 results by default. 
         * @summary Trending Stickers
         * @param {number} [limit] The maximum number of records to return.
         * @param {number} [offset] An optional results offset.
         * @param {string} [rating] Filters results by specified rating.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trendingStickers(limit?: number, offset?: number, rating?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
            const localVarFetchArgs = StickersApiFetchParamCreator(configuration).trendingStickers(limit, offset, rating, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * StickersApi - factory interface
 * @export
 */
export const StickersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns a random GIF, limited by tag. Excluding the tag parameter will return a random GIF from the GIPHY catalog. 
         * @summary Random Sticker
         * @param {string} [tag] Filters results by specified tag.
         * @param {string} [rating] Filters results by specified rating.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        randomSticker(tag?: string, rating?: string, options?: any) {
            return StickersApiFp(configuration).randomSticker(tag, rating, options)(fetch, basePath);
        },
        /**
         * Replicates the functionality and requirements of the classic GIPHY search, but returns animated stickers rather than GIFs. 
         * @summary Search Stickers
         * @param {string} q Search query term or prhase.
         * @param {number} [limit] The maximum number of records to return.
         * @param {number} [offset] An optional results offset.
         * @param {string} [rating] Filters results by specified rating.
         * @param {string} [lang] Specify default language for regional content; use a 2-letter ISO 639-1 language code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchStickers(q: string, limit?: number, offset?: number, rating?: string, lang?: string, options?: any) {
            return StickersApiFp(configuration).searchStickers(q, limit, offset, rating, lang, options)(fetch, basePath);
        },
        /**
         * The translate API draws on search, but uses the GIPHY `special sauce` to handle translating from one vocabulary to another. In this case, words and phrases to GIFs. 
         * @summary Translate phrase to Sticker
         * @param {string} s Search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translateSticker(s: string, options?: any) {
            return StickersApiFp(configuration).translateSticker(s, options)(fetch, basePath);
        },
        /**
         * Fetch Stickers currently trending online. Hand curated by the GIPHY editorial team. Returns 25 results by default. 
         * @summary Trending Stickers
         * @param {number} [limit] The maximum number of records to return.
         * @param {number} [offset] An optional results offset.
         * @param {string} [rating] Filters results by specified rating.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trendingStickers(limit?: number, offset?: number, rating?: string, options?: any) {
            return StickersApiFp(configuration).trendingStickers(limit, offset, rating, options)(fetch, basePath);
        },
    };
};

/**
 * StickersApi - object-oriented interface
 * @export
 * @class StickersApi
 * @extends {BaseAPI}
 */
export class StickersApi extends BaseAPI {
    /**
     * Returns a random GIF, limited by tag. Excluding the tag parameter will return a random GIF from the GIPHY catalog. 
     * @summary Random Sticker
     * @param {string} [tag] Filters results by specified tag.
     * @param {string} [rating] Filters results by specified rating.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StickersApi
     */
    public randomSticker(tag?: string, rating?: string, options?: any) {
        return StickersApiFp(this.configuration).randomSticker(tag, rating, options)(this.fetch, this.basePath);
    }

    /**
     * Replicates the functionality and requirements of the classic GIPHY search, but returns animated stickers rather than GIFs. 
     * @summary Search Stickers
     * @param {string} q Search query term or prhase.
     * @param {number} [limit] The maximum number of records to return.
     * @param {number} [offset] An optional results offset.
     * @param {string} [rating] Filters results by specified rating.
     * @param {string} [lang] Specify default language for regional content; use a 2-letter ISO 639-1 language code.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StickersApi
     */
    public searchStickers(q: string, limit?: number, offset?: number, rating?: string, lang?: string, options?: any) {
        return StickersApiFp(this.configuration).searchStickers(q, limit, offset, rating, lang, options)(this.fetch, this.basePath);
    }

    /**
     * The translate API draws on search, but uses the GIPHY `special sauce` to handle translating from one vocabulary to another. In this case, words and phrases to GIFs. 
     * @summary Translate phrase to Sticker
     * @param {string} s Search term.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StickersApi
     */
    public translateSticker(s: string, options?: any) {
        return StickersApiFp(this.configuration).translateSticker(s, options)(this.fetch, this.basePath);
    }

    /**
     * Fetch Stickers currently trending online. Hand curated by the GIPHY editorial team. Returns 25 results by default. 
     * @summary Trending Stickers
     * @param {number} [limit] The maximum number of records to return.
     * @param {number} [offset] An optional results offset.
     * @param {string} [rating] Filters results by specified rating.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StickersApi
     */
    public trendingStickers(limit?: number, offset?: number, rating?: string, options?: any) {
        return StickersApiFp(this.configuration).trendingStickers(limit, offset, rating, options)(this.fetch, this.basePath);
    }

}

